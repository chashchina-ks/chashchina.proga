# Чащина Ксения Владимировна ИВТ-1.2

## Тема: Структуры. Объединения. Перечисления.

_ _ _

### **Задание 1.1.**
Создать некоторую структуру с указателем на некоторую функцию в качестве поля. Вызвать эту функцию через имя переменной этой структуры и поле указателя на функцию.
_ _ _

**Список идентификаторов:**
| Имя | Тип    | Описание                           |
|-----|--------|------------------------------------|
| pointer   | double ***    | Тройной указатель        |
| -   | double **    | Указатель, на который хранит адрес double*        |
| - | double *    | Указатель, на который хранит адрес double               |
| - | double    | Переменная, в которой хранится 2.0               |

**Код программы:**
```c

```

**Результат выполненной работы:**
![](3.1.1.png)

_ _ _

### **Задание 1.2.**
Создать структуру для вектора в 3-х мерном пространстве. Реализовать и использовать в своей программе следующие операции над
векторами:
- скалярное умножение векторов;
- векторное произведение;
- модуль вектора;
- распечатка вектора в консоли.

В структуре вектора указать имя вектора в качестве отдельного поля этой структуры
_ _ _

**Математическая модель:**

Скалярное произведение:  

$$
\vec{a} \cdot \vec{b} = a_x b_x + a_y b_y + a_z b_z
$$

Векторное произведение:  

$$
\vec{a} \times \vec{b} = 
\begin{vmatrix}
\vec{i} & \vec{j} & \vec{k} \\
a_x & a_y & a_z \\
b_x & b_y & b_z
\end{vmatrix} 
= \vec{i} \cdot (a_y b_z - a_z b_y) - \vec{j} \cdot (a_x b_z - a_z b_x) + \vec{k} \cdot (a_x b_y - a_y b_x)
$$

Модуль вектора:  

$$
|v| = \sqrt{v_x^2 + v_y^2 + v_z^2}
$$

**Список идентификаторов:**
| Имя | Тип    | Описание                           |
|-----|--------|------------------------------------|
| Vec   | struct    | Структура для 3D вектора        |
| x, y, z   | double   | Координаты вектора        |
| scalarProduct | double    | Скалярное произведение               |
| crossProduct | Vec    | Векторное произведение               |
| vectorModule | double    | Модуль векторов               |
| printVector | void    | Функция для вывода               |
| vector1, vector2 | Vec    | Введимые вектора               |
| cross_product | Vec    | Результат векторного произведения             |

**Код программы:**
```c
#include <stdio.h>
#include <math.h>
#include <string.h>

typedef struct {
    char name[50]; 
    double x, y, z;  
} Vec;

double scalarProduct(Vec v1, Vec v2) {
    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
}

Vec crossProduct(Vec v1, Vec v2) {
    Vec result;
    result.x = v1.y * v2.z - v1.z * v2.y;
    result.y = v1.z * v2.x - v1.x * v2.z;
    result.z = v1.x * v2.y - v1.y * v2.x;
    return result;
}

double vectorModule(Vec v) {
    return sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
}

void printVector(Vec v) {
    printf("Vector %s: (%.2f, %.2f, %.2f)\n", v.name, v.x, v.y, v.z);
}

int main() {
    Vec vector1, vector2, cross_product;
    strcpy(vector1.name, "A");
    vector1.x = 1.0;
    vector1.y = 2.0;
    vector1.z = 3.0;
    strcpy(vector2.name, "B");
    vector2.x = 4.0;
    vector2.y = 5.0;
    vector2.z = 6.0;
    printVector(vector1);
    printVector(vector2);
    double scalar_product = scalarProduct(vector1, vector2);
    printf("Scalar product A * B: %.2f\n", scalar_product);
    cross_product = crossProduct(vector1, vector2);
    strcpy(cross_product.name, "C"); 
    printf("Cross product A x B: ");
    printVector(cross_product);
    double module1 = vectorModule(vector1);
    printf("Vector modulus A: %.2f\n", module1);
    double module2 = vectorModule(vector2);
    printf("Vector modulus B: %.2f\n", module2);

    return 0;
}
```

**Результат выполненной работы:**
![](3.1.2.png)

_ _ _

### **Задание 1.3.**
Вычислить, используя структуру комплексного числа, комплексную экспоненту $\exp{z}$ некоторого $z \in \mathbb{C}$
_ _ _

**Математическая модель:**

$$
\exp{z} = 1 + z + \frac{1}{2!}z^2 + \frac{1}{3!}z^3 + \dots + \frac{1}{n!}z^n
$$


**Список идентификаторов:**
| Имя | Тип    | Описание                           |
|-----|--------|------------------------------------|
| Complex   | struct    | Структура для комплексного числа        |
| real   | double   | Действительная часть        |
| imag | double    | Мнимая часть               |
| complexMultiply | Complex    | Умножение комплексных чисел               |
| factorial | double    | Функция для нахождения факториала               |
| complexExp | Complex    | Вычисление экспоненты               |
| result | Complex    | Начальное значение               |
| term | Complex    | Текущий член разложения               |
| z_power | Complex    | Значение степени z               |
| fact | double    | Значение факториала               |
| exp_z | Complex    | Результат вычисления           |

**Код программы:**
```c
#include <stdio.h>
#include <math.h>

typedef struct {
    double real;   
    double imag;  
} Complex;

Complex complexMultiply(Complex z1, Complex z2) {
    Complex result;
    result.real = z1.real * z2.real - z1.imag * z2.imag;
    result.imag = z1.real * z2.imag + z1.imag * z2.real;
    return result;
}

double factorial(int n) {
    double result = 1.0;
    for (int i = 1; i <= n; ++i) {
        result *= i;
    }
    return result;
}


Complex complexExp(Complex z, int n) {
    Complex result = {1.0, 0.0}; 
    Complex term = {1.0, 0.0};  
    Complex z_power = {1.0, 0.0}; 
    double fact;
    for (int i = 1; i <= n; ++i) {
        z_power = complexMultiply(z_power, z);
        fact = factorial(i);
        term.real = z_power.real / fact; 
        term.imag = z_power.imag / fact;
        result.real += term.real;
        result.imag += term.imag;
    }

    return result;
}

int main() {
    Complex z;
    int n;
    printf("Input the imaginary part of z: ");
    scanf("%lf", &z.real);
    printf("Input the real part of z: ");
    scanf("%lf", &z.imag);
    printf("Input n: ");
    scanf("%d", &n);
    Complex exp_z = complexExp(z, n);
    printf("exp(%.2f + %.2fi) = %.2f + %.2fi\n", z.real, z.imag, exp_z.real, exp_z.imag);
    return 0;
}
```

**Результат выполненной работы:**
![](3.1.3.png)

_ _ _

### **Задание 1.4.**
Используя так называемые "битовые" поля в структуре C, создать экономную структуру в оперативной памяти для заполнения даты некоторого события, например даты рождения человека.
_ _ _

**Список идентификаторов:**
| Имя | Тип    | Описание                           |
|-----|--------|------------------------------------|
| BirthDate   | struct    | Структура для даты рождения в битовых полях        |
| day   | unsigned int   | День        |
| month | unsigned int    | Месяц              |
| year | unsigned int    | Год              |
| birth_date | BirthDate    | Экземпляр структуры               |

**Код программы:**
```c
#include <stdio.h>

typedef struct {
  unsigned int day   : 5;   
  unsigned int month : 4;   
  unsigned int year  : 12; 
} BirthDate;

int main() {
  BirthDate birth_date;
  birth_date.day   = 25;    
  birth_date.month = 6;      
  birth_date.year  = 2006;  
  printf("Birth date: %u.%u.%u\n", birth_date.day, birth_date.month, birth_date.year);

  return 0;
}
```

**Результат выполненной работы:**
![](3.1.4.png)

